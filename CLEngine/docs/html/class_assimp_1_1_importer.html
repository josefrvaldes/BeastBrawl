<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CLEngine: Assimp::Importer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CLEngine
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Motor gr√°fico para TAG</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_assimp_1_1_importer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_assimp_1_1_importer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Assimp::Importer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CPP-API: The <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> class forms an C++ interface to the functionality of the Open Asset Import Library.  
 <a href="class_assimp_1_1_importer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_importer_8hpp_source.html">Importer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c207299ed05f1db1ad1e6dab005f719"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a2c207299ed05f1db1ad1e6dab005f719">Importer</a> ()</td></tr>
<tr class="memdesc:a2c207299ed05f1db1ad1e6dab005f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_assimp_1_1_importer.html#a2c207299ed05f1db1ad1e6dab005f719">More...</a><br /></td></tr>
<tr class="separator:a2c207299ed05f1db1ad1e6dab005f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69743664b5a7a8c195be48265144317b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a69743664b5a7a8c195be48265144317b">Importer</a> (const <a class="el" href="class_assimp_1_1_importer.html">Importer</a> &amp;other)</td></tr>
<tr class="memdesc:a69743664b5a7a8c195be48265144317b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="class_assimp_1_1_importer.html#a69743664b5a7a8c195be48265144317b">More...</a><br /></td></tr>
<tr class="separator:a69743664b5a7a8c195be48265144317b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d65af5286ba22f46220a72a6eb2a1c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a3d65af5286ba22f46220a72a6eb2a1c9">~Importer</a> ()</td></tr>
<tr class="memdesc:a3d65af5286ba22f46220a72a6eb2a1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_assimp_1_1_importer.html#a3d65af5286ba22f46220a72a6eb2a1c9">More...</a><br /></td></tr>
<tr class="separator:a3d65af5286ba22f46220a72a6eb2a1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3846294ffe76d91a1d3096d22d7c6b7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1f78dfb65090aa930cabb984c8abe711">aiReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a3846294ffe76d91a1d3096d22d7c6b7d">RegisterLoader</a> (BaseImporter *pImp)</td></tr>
<tr class="memdesc:a3846294ffe76d91a1d3096d22d7c6b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new loader.  <a href="class_assimp_1_1_importer.html#a3846294ffe76d91a1d3096d22d7c6b7d">More...</a><br /></td></tr>
<tr class="separator:a3846294ffe76d91a1d3096d22d7c6b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1f5af2c763b13aca0f324b19001722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1f78dfb65090aa930cabb984c8abe711">aiReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a3b1f5af2c763b13aca0f324b19001722">UnregisterLoader</a> (BaseImporter *pImp)</td></tr>
<tr class="memdesc:a3b1f5af2c763b13aca0f324b19001722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a loader.  <a href="class_assimp_1_1_importer.html#a3b1f5af2c763b13aca0f324b19001722">More...</a><br /></td></tr>
<tr class="separator:a3b1f5af2c763b13aca0f324b19001722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102650d3648c0e414a1e73bdad9bed35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1f78dfb65090aa930cabb984c8abe711">aiReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a102650d3648c0e414a1e73bdad9bed35">RegisterPPStep</a> (BaseProcess *pImp)</td></tr>
<tr class="memdesc:a102650d3648c0e414a1e73bdad9bed35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new post-process step.  <a href="class_assimp_1_1_importer.html#a102650d3648c0e414a1e73bdad9bed35">More...</a><br /></td></tr>
<tr class="separator:a102650d3648c0e414a1e73bdad9bed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a683671c7c40638b1103c5d3648d86c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a1f78dfb65090aa930cabb984c8abe711">aiReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a3a683671c7c40638b1103c5d3648d86c">UnregisterPPStep</a> (BaseProcess *pImp)</td></tr>
<tr class="memdesc:a3a683671c7c40638b1103c5d3648d86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a post-process step.  <a href="class_assimp_1_1_importer.html#a3a683671c7c40638b1103c5d3648d86c">More...</a><br /></td></tr>
<tr class="separator:a3a683671c7c40638b1103c5d3648d86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2542eed3d5f491025c4095b4e55fa068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a2542eed3d5f491025c4095b4e55fa068">SetPropertyInteger</a> (const char *szName, int iValue)</td></tr>
<tr class="memdesc:a2542eed3d5f491025c4095b4e55fa068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an integer configuration property.  <a href="class_assimp_1_1_importer.html#a2542eed3d5f491025c4095b4e55fa068">More...</a><br /></td></tr>
<tr class="separator:a2542eed3d5f491025c4095b4e55fa068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af22a88eddf464d949a761149c72825"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a4af22a88eddf464d949a761149c72825">SetPropertyBool</a> (const char *szName, bool value)</td></tr>
<tr class="memdesc:a4af22a88eddf464d949a761149c72825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a boolean configuration property.  <a href="class_assimp_1_1_importer.html#a4af22a88eddf464d949a761149c72825">More...</a><br /></td></tr>
<tr class="separator:a4af22a88eddf464d949a761149c72825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38af78d6fe4b1f132d2534d8a84deea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#ad38af78d6fe4b1f132d2534d8a84deea">SetPropertyFloat</a> (const char *szName, <a class="el" href="defs_8h.html#af221f9bbc3e0dc43a46efaaac6dab067">ai_real</a> fValue)</td></tr>
<tr class="memdesc:ad38af78d6fe4b1f132d2534d8a84deea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a floating-point configuration property.  <a href="class_assimp_1_1_importer.html#ad38af78d6fe4b1f132d2534d8a84deea">More...</a><br /></td></tr>
<tr class="separator:ad38af78d6fe4b1f132d2534d8a84deea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854087b213981108e3e464cf4d293fed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a854087b213981108e3e464cf4d293fed">SetPropertyString</a> (const char *szName, const std::string &amp;sValue)</td></tr>
<tr class="memdesc:a854087b213981108e3e464cf4d293fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a string configuration property.  <a href="class_assimp_1_1_importer.html#a854087b213981108e3e464cf4d293fed">More...</a><br /></td></tr>
<tr class="separator:a854087b213981108e3e464cf4d293fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd128e5fb5777ef238b8bd1454a9c3ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#acd128e5fb5777ef238b8bd1454a9c3ad">SetPropertyMatrix</a> (const char *szName, const <a class="el" href="structai_matrix4x4.html">aiMatrix4x4</a> &amp;sValue)</td></tr>
<tr class="memdesc:acd128e5fb5777ef238b8bd1454a9c3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a matrix configuration property.  <a href="class_assimp_1_1_importer.html#acd128e5fb5777ef238b8bd1454a9c3ad">More...</a><br /></td></tr>
<tr class="separator:acd128e5fb5777ef238b8bd1454a9c3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f348464e03176bc6dd790226122b36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#ac6f348464e03176bc6dd790226122b36">GetPropertyInteger</a> (const char *szName, int iErrorReturn=0xffffffff) const</td></tr>
<tr class="memdesc:ac6f348464e03176bc6dd790226122b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a configuration property.  <a href="class_assimp_1_1_importer.html#ac6f348464e03176bc6dd790226122b36">More...</a><br /></td></tr>
<tr class="separator:ac6f348464e03176bc6dd790226122b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e654c887f684cc12f792ca1daebfee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a39e654c887f684cc12f792ca1daebfee">GetPropertyBool</a> (const char *szName, bool bErrorReturn=false) const</td></tr>
<tr class="memdesc:a39e654c887f684cc12f792ca1daebfee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a boolean configuration property.  <a href="class_assimp_1_1_importer.html#a39e654c887f684cc12f792ca1daebfee">More...</a><br /></td></tr>
<tr class="separator:a39e654c887f684cc12f792ca1daebfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5f327bc30dfe95db6d8ff9297d4aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="defs_8h.html#af221f9bbc3e0dc43a46efaaac6dab067">ai_real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a3a5f327bc30dfe95db6d8ff9297d4aab">GetPropertyFloat</a> (const char *szName, <a class="el" href="defs_8h.html#af221f9bbc3e0dc43a46efaaac6dab067">ai_real</a> fErrorReturn=10e10) const</td></tr>
<tr class="memdesc:a3a5f327bc30dfe95db6d8ff9297d4aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a floating-point configuration property.  <a href="class_assimp_1_1_importer.html#a3a5f327bc30dfe95db6d8ff9297d4aab">More...</a><br /></td></tr>
<tr class="separator:a3a5f327bc30dfe95db6d8ff9297d4aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc97e5eeaa39c9d7b6fb60703b78cdf0"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#afc97e5eeaa39c9d7b6fb60703b78cdf0">GetPropertyString</a> (const char *szName, const std::string &amp;sErrorReturn=&quot;&quot;) const</td></tr>
<tr class="memdesc:afc97e5eeaa39c9d7b6fb60703b78cdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string configuration property.  <a href="class_assimp_1_1_importer.html#afc97e5eeaa39c9d7b6fb60703b78cdf0">More...</a><br /></td></tr>
<tr class="separator:afc97e5eeaa39c9d7b6fb60703b78cdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53665d41547cc298c53b5341c99ee60e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_matrix4x4.html">aiMatrix4x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a53665d41547cc298c53b5341c99ee60e">GetPropertyMatrix</a> (const char *szName, const <a class="el" href="structai_matrix4x4.html">aiMatrix4x4</a> &amp;sErrorReturn=<a class="el" href="structai_matrix4x4.html">aiMatrix4x4</a>()) const</td></tr>
<tr class="memdesc:a53665d41547cc298c53b5341c99ee60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a matrix configuration property.  <a href="class_assimp_1_1_importer.html#a53665d41547cc298c53b5341c99ee60e">More...</a><br /></td></tr>
<tr class="separator:a53665d41547cc298c53b5341c99ee60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1161f46318af18bb86dfe0fc3edea4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a1161f46318af18bb86dfe0fc3edea4df">SetIOHandler</a> (<a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *pIOHandler)</td></tr>
<tr class="memdesc:a1161f46318af18bb86dfe0fc3edea4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies a custom IO handler to the importer to use to open and access files.  <a href="class_assimp_1_1_importer.html#a1161f46318af18bb86dfe0fc3edea4df">More...</a><br /></td></tr>
<tr class="separator:a1161f46318af18bb86dfe0fc3edea4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f4d2821d38b97f630981f9236901e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a72f4d2821d38b97f630981f9236901e8">GetIOHandler</a> () const</td></tr>
<tr class="memdesc:a72f4d2821d38b97f630981f9236901e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the IO handler that is currently set.  <a href="class_assimp_1_1_importer.html#a72f4d2821d38b97f630981f9236901e8">More...</a><br /></td></tr>
<tr class="separator:a72f4d2821d38b97f630981f9236901e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c940def9c4d01709e44a4e781e757d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#ad2c940def9c4d01709e44a4e781e757d">IsDefaultIOHandler</a> () const</td></tr>
<tr class="memdesc:ad2c940def9c4d01709e44a4e781e757d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a default IO handler is active A default handler is active as long the application doesn't supply its own custom IO handler via <a class="el" href="class_assimp_1_1_importer.html#a1161f46318af18bb86dfe0fc3edea4df" title="Supplies a custom IO handler to the importer to use to open and access files.">SetIOHandler()</a>.  <a href="class_assimp_1_1_importer.html#ad2c940def9c4d01709e44a4e781e757d">More...</a><br /></td></tr>
<tr class="separator:ad2c940def9c4d01709e44a4e781e757d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4d830ffb3f77a3c7c919e0af006920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a6a4d830ffb3f77a3c7c919e0af006920">SetProgressHandler</a> (<a class="el" href="class_assimp_1_1_progress_handler.html">ProgressHandler</a> *pHandler)</td></tr>
<tr class="memdesc:a6a4d830ffb3f77a3c7c919e0af006920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies a custom progress handler to the importer.  <a href="class_assimp_1_1_importer.html#a6a4d830ffb3f77a3c7c919e0af006920">More...</a><br /></td></tr>
<tr class="separator:a6a4d830ffb3f77a3c7c919e0af006920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14201de344db7c66fa514f7f092ae10b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_assimp_1_1_progress_handler.html">ProgressHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a14201de344db7c66fa514f7f092ae10b">GetProgressHandler</a> () const</td></tr>
<tr class="memdesc:a14201de344db7c66fa514f7f092ae10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the progress handler that is currently set.  <a href="class_assimp_1_1_importer.html#a14201de344db7c66fa514f7f092ae10b">More...</a><br /></td></tr>
<tr class="separator:a14201de344db7c66fa514f7f092ae10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34062906cb6b9af8abaeda36737d14ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a34062906cb6b9af8abaeda36737d14ae">IsDefaultProgressHandler</a> () const</td></tr>
<tr class="memdesc:a34062906cb6b9af8abaeda36737d14ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a default progress handler is active A default handler is active as long the application doesn't supply its own custom progress handler via <a class="el" href="class_assimp_1_1_importer.html#a6a4d830ffb3f77a3c7c919e0af006920" title="Supplies a custom progress handler to the importer.">SetProgressHandler()</a>.  <a href="class_assimp_1_1_importer.html#a34062906cb6b9af8abaeda36737d14ae">More...</a><br /></td></tr>
<tr class="separator:a34062906cb6b9af8abaeda36737d14ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0292c1603ff9b483a5deba4d183eba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#af0292c1603ff9b483a5deba4d183eba5">ValidateFlags</a> (unsigned int pFlags) const</td></tr>
<tr class="memdesc:af0292c1603ff9b483a5deba4d183eba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given set of post-processing flags is supported.  <a href="class_assimp_1_1_importer.html#af0292c1603ff9b483a5deba4d183eba5">More...</a><br /></td></tr>
<tr class="separator:af0292c1603ff9b483a5deba4d183eba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174418ab41d5b8bc51a044895cb991e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_scene.html">aiScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5">ReadFile</a> (const char *pFile, unsigned int pFlags)</td></tr>
<tr class="memdesc:a174418ab41d5b8bc51a044895cb991e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the given file and returns its contents if successful.  <a href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5">More...</a><br /></td></tr>
<tr class="separator:a174418ab41d5b8bc51a044895cb991e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3c5e8b1042702f449e84a95b3324f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_scene.html">aiScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a9b3c5e8b1042702f449e84a95b3324f6">ReadFileFromMemory</a> (const void *pBuffer, size_t pLength, unsigned int pFlags, const char *pHint=&quot;&quot;)</td></tr>
<tr class="memdesc:a9b3c5e8b1042702f449e84a95b3324f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the given file from a memory buffer and returns its contents if successful.  <a href="class_assimp_1_1_importer.html#a9b3c5e8b1042702f449e84a95b3324f6">More...</a><br /></td></tr>
<tr class="separator:a9b3c5e8b1042702f449e84a95b3324f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5872e749c1451fee64183fc14f1fc81d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_scene.html">aiScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a5872e749c1451fee64183fc14f1fc81d">ApplyPostProcessing</a> (unsigned int pFlags)</td></tr>
<tr class="memdesc:a5872e749c1451fee64183fc14f1fc81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply post-processing to an already-imported scene.  <a href="class_assimp_1_1_importer.html#a5872e749c1451fee64183fc14f1fc81d">More...</a><br /></td></tr>
<tr class="separator:a5872e749c1451fee64183fc14f1fc81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba00e5dd1cb5ed67f709e994933efb39"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_scene.html">aiScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#aba00e5dd1cb5ed67f709e994933efb39">ApplyCustomizedPostProcessing</a> (BaseProcess *rootProcess, bool requestValidation)</td></tr>
<tr class="separator:aba00e5dd1cb5ed67f709e994933efb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a9f3905924744b2cdce0f3fc131a87"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_scene.html">aiScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#ad9a9f3905924744b2cdce0f3fc131a87">ReadFile</a> (const std::string &amp;pFile, unsigned int pFlags)</td></tr>
<tr class="memdesc:ad9a9f3905924744b2cdce0f3fc131a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the given file and returns its contents if successful.  <a href="class_assimp_1_1_importer.html#ad9a9f3905924744b2cdce0f3fc131a87">More...</a><br /></td></tr>
<tr class="separator:ad9a9f3905924744b2cdce0f3fc131a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dafc3046abc33365a07c605716c5d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a53dafc3046abc33365a07c605716c5d4">FreeScene</a> ()</td></tr>
<tr class="memdesc:a53dafc3046abc33365a07c605716c5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the current scene.  <a href="class_assimp_1_1_importer.html#a53dafc3046abc33365a07c605716c5d4">More...</a><br /></td></tr>
<tr class="separator:a53dafc3046abc33365a07c605716c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac36c9ab8668bd368de516c19bdcc11"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a3ac36c9ab8668bd368de516c19bdcc11">GetErrorString</a> () const</td></tr>
<tr class="memdesc:a3ac36c9ab8668bd368de516c19bdcc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an error description of an error that occurred in <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>.  <a href="class_assimp_1_1_importer.html#a3ac36c9ab8668bd368de516c19bdcc11">More...</a><br /></td></tr>
<tr class="separator:a3ac36c9ab8668bd368de516c19bdcc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f94a29007ed7c873be138ecdb4b056"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_scene.html">aiScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#ae5f94a29007ed7c873be138ecdb4b056">GetScene</a> () const</td></tr>
<tr class="memdesc:ae5f94a29007ed7c873be138ecdb4b056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scene loaded by the last successful call to <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>  <a href="class_assimp_1_1_importer.html#ae5f94a29007ed7c873be138ecdb4b056">More...</a><br /></td></tr>
<tr class="separator:ae5f94a29007ed7c873be138ecdb4b056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60eb9042fb85bfbd61a863e131a56ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structai_scene.html">aiScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a60eb9042fb85bfbd61a863e131a56ecd">GetOrphanedScene</a> ()</td></tr>
<tr class="memdesc:a60eb9042fb85bfbd61a863e131a56ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scene loaded by the last successful call to <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> and releases the scene from the ownership of the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance.  <a href="class_assimp_1_1_importer.html#a60eb9042fb85bfbd61a863e131a56ecd">More...</a><br /></td></tr>
<tr class="separator:a60eb9042fb85bfbd61a863e131a56ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bbe0ca29cc685b110b6853dd1e4157"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a22bbe0ca29cc685b110b6853dd1e4157">IsExtensionSupported</a> (const char *szExtension) const</td></tr>
<tr class="memdesc:a22bbe0ca29cc685b110b6853dd1e4157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given file extension is supported by ASSIMP.  <a href="class_assimp_1_1_importer.html#a22bbe0ca29cc685b110b6853dd1e4157">More...</a><br /></td></tr>
<tr class="separator:a22bbe0ca29cc685b110b6853dd1e4157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d49e3c8ecf28336d78f9f5e502990ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a4d49e3c8ecf28336d78f9f5e502990ce">IsExtensionSupported</a> (const std::string &amp;szExtension) const</td></tr>
<tr class="memdesc:a4d49e3c8ecf28336d78f9f5e502990ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given file extension is supported by ASSIMP.  <a href="class_assimp_1_1_importer.html#a4d49e3c8ecf28336d78f9f5e502990ce">More...</a><br /></td></tr>
<tr class="separator:a4d49e3c8ecf28336d78f9f5e502990ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06927d45d5adbf909040c8f5bac1e4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#ab06927d45d5adbf909040c8f5bac1e4d">GetExtensionList</a> (<a class="el" href="structai_string.html">aiString</a> &amp;szOut) const</td></tr>
<tr class="memdesc:ab06927d45d5adbf909040c8f5bac1e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a full list of all file extensions supported by ASSIMP.  <a href="class_assimp_1_1_importer.html#ab06927d45d5adbf909040c8f5bac1e4d">More...</a><br /></td></tr>
<tr class="separator:ab06927d45d5adbf909040c8f5bac1e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc70c6efdf1b572094fe01089ceb158"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#acdc70c6efdf1b572094fe01089ceb158">GetExtensionList</a> (std::string &amp;szOut) const</td></tr>
<tr class="memdesc:acdc70c6efdf1b572094fe01089ceb158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a full list of all file extensions supported by ASSIMP.  <a href="class_assimp_1_1_importer.html#acdc70c6efdf1b572094fe01089ceb158">More...</a><br /></td></tr>
<tr class="separator:acdc70c6efdf1b572094fe01089ceb158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5397c7d93358b1a6983c74c5eb5c64a6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a5397c7d93358b1a6983c74c5eb5c64a6">GetImporterCount</a> () const</td></tr>
<tr class="memdesc:a5397c7d93358b1a6983c74c5eb5c64a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of importers currently registered with <a class="el" href="namespace_assimp.html">Assimp</a>.  <a href="class_assimp_1_1_importer.html#a5397c7d93358b1a6983c74c5eb5c64a6">More...</a><br /></td></tr>
<tr class="separator:a5397c7d93358b1a6983c74c5eb5c64a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9db052a2507d3a77aec782dc8149cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structai_importer_desc.html">aiImporterDesc</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a2f9db052a2507d3a77aec782dc8149cf">GetImporterInfo</a> (size_t index) const</td></tr>
<tr class="memdesc:a2f9db052a2507d3a77aec782dc8149cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get meta data for the importer corresponding to a specific index.  <a href="class_assimp_1_1_importer.html#a2f9db052a2507d3a77aec782dc8149cf">More...</a><br /></td></tr>
<tr class="separator:a2f9db052a2507d3a77aec782dc8149cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913543b8db0f09f286cc1b4f20bb3d35"><td class="memItemLeft" align="right" valign="top">BaseImporter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a913543b8db0f09f286cc1b4f20bb3d35">GetImporter</a> (size_t index) const</td></tr>
<tr class="memdesc:a913543b8db0f09f286cc1b4f20bb3d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the importer corresponding to a specific index.  <a href="class_assimp_1_1_importer.html#a913543b8db0f09f286cc1b4f20bb3d35">More...</a><br /></td></tr>
<tr class="separator:a913543b8db0f09f286cc1b4f20bb3d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d624811e9ddfcd0a898797e6263c22"><td class="memItemLeft" align="right" valign="top">BaseImporter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a35d624811e9ddfcd0a898797e6263c22">GetImporter</a> (const char *szExtension) const</td></tr>
<tr class="memdesc:a35d624811e9ddfcd0a898797e6263c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the importer corresponding to a specific file extension.  <a href="class_assimp_1_1_importer.html#a35d624811e9ddfcd0a898797e6263c22">More...</a><br /></td></tr>
<tr class="separator:a35d624811e9ddfcd0a898797e6263c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9158a5ec0caba90cb1a3183c065634f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#aa9158a5ec0caba90cb1a3183c065634f">GetImporterIndex</a> (const char *szExtension) const</td></tr>
<tr class="memdesc:aa9158a5ec0caba90cb1a3183c065634f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the importer index corresponding to a specific file extension.  <a href="class_assimp_1_1_importer.html#aa9158a5ec0caba90cb1a3183c065634f">More...</a><br /></td></tr>
<tr class="separator:aa9158a5ec0caba90cb1a3183c065634f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6cd3b06de9438744a17f61395a0bf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a6d6cd3b06de9438744a17f61395a0bf0">GetMemoryRequirements</a> (<a class="el" href="structai_memory_info.html">aiMemoryInfo</a> &amp;in) const</td></tr>
<tr class="memdesc:a6d6cd3b06de9438744a17f61395a0bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the storage allocated by ASSIMP to hold the scene data in memory.  <a href="class_assimp_1_1_importer.html#a6d6cd3b06de9438744a17f61395a0bf0">More...</a><br /></td></tr>
<tr class="separator:a6d6cd3b06de9438744a17f61395a0bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb793072c84c784279d0f6e870bb42d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a9bb793072c84c784279d0f6e870bb42d">SetExtraVerbose</a> (bool bDo)</td></tr>
<tr class="memdesc:a9bb793072c84c784279d0f6e870bb42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables "extra verbose" mode.  <a href="class_assimp_1_1_importer.html#a9bb793072c84c784279d0f6e870bb42d">More...</a><br /></td></tr>
<tr class="separator:a9bb793072c84c784279d0f6e870bb42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac112839f323a630f83395acb74746827"><td class="memItemLeft" align="right" valign="top">ImporterPimpl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#ac112839f323a630f83395acb74746827">Pimpl</a> ()</td></tr>
<tr class="memdesc:ac112839f323a630f83395acb74746827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private, do not use.  <a href="class_assimp_1_1_importer.html#ac112839f323a630f83395acb74746827">More...</a><br /></td></tr>
<tr class="separator:ac112839f323a630f83395acb74746827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a85077725374402b4d6e107b03ce845"><td class="memItemLeft" align="right" valign="top">const ImporterPimpl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a5a85077725374402b4d6e107b03ce845">Pimpl</a> () const</td></tr>
<tr class="separator:a5a85077725374402b4d6e107b03ce845"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3affe8f98fc9a3b75fc3cb4c4415b37c"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a3affe8f98fc9a3b75fc3cb4c4415b37c">MaxLenHint</a> = 200</td></tr>
<tr class="memdesc:a3affe8f98fc9a3b75fc3cb4c4415b37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The upper limit for hints.  <a href="class_assimp_1_1_importer.html#a3affe8f98fc9a3b75fc3cb4c4415b37c">More...</a><br /></td></tr>
<tr class="separator:a3affe8f98fc9a3b75fc3cb4c4415b37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3928bb8d375fd676dd5dbe33382e46ce"><td class="memItemLeft" align="right" valign="top">ImporterPimpl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_importer.html#a3928bb8d375fd676dd5dbe33382e46ce">pimpl</a></td></tr>
<tr class="separator:a3928bb8d375fd676dd5dbe33382e46ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CPP-API: The <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> class forms an C++ interface to the functionality of the Open Asset Import Library. </p>
<p>Create an object of this class and call <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> to import a file. If the import succeeds, the function returns a pointer to the imported data. The data remains property of the object, it is intended to be accessed read-only. The imported data will be destroyed along with the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> object. If the import fails, <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> returns a NULL pointer. In this case you can retrieve a human-readable error description be calling <a class="el" href="class_assimp_1_1_importer.html#a3ac36c9ab8668bd368de516c19bdcc11" title="Returns an error description of an error that occurred in ReadFile().">GetErrorString()</a>. You can call <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> multiple times with a single <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance. Actually, constructing <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> objects involves quite many allocations and may take some time, so it's better to reuse them as often as possible.</p>
<p>If you need the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> to do custom file handling to access the files, implement <a class="el" href="class_assimp_1_1_i_o_system.html" title="CPP-API: Interface to the file system.">IOSystem</a> and <a class="el" href="class_assimp_1_1_i_o_stream.html" title="CPP-API: Class to handle file I/O for C++.">IOStream</a> and supply an instance of your custom <a class="el" href="class_assimp_1_1_i_o_system.html" title="CPP-API: Interface to the file system.">IOSystem</a> implementation by calling <a class="el" href="class_assimp_1_1_importer.html#a1161f46318af18bb86dfe0fc3edea4df" title="Supplies a custom IO handler to the importer to use to open and access files.">SetIOHandler()</a> before calling <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>. If you do not assign a custion IO handler, a default handler using the standard C++ IO logic will be used.</p>
<dl class="section note"><dt>Note</dt><dd>One <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance is not thread-safe. If you use multiple threads for loading, each thread should maintain its own <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2c207299ed05f1db1ad1e6dab005f719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c207299ed05f1db1ad1e6dab005f719">&#9670;&nbsp;</a></span>Importer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assimp::Importer::Importer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Creates an empty importer object.</p>
<p>Call <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> to start the import process. The configuration property table is initially empty. </p>

</div>
</div>
<a id="a69743664b5a7a8c195be48265144317b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69743664b5a7a8c195be48265144317b">&#9670;&nbsp;</a></span>Importer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assimp::Importer::Importer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_assimp_1_1_importer.html">Importer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>This copies the configuration properties of another <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a>. If this <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> owns a scene it won't be copied. Call <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> to start the import process. </p>

</div>
</div>
<a id="a3d65af5286ba22f46220a72a6eb2a1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d65af5286ba22f46220a72a6eb2a1c9">&#9670;&nbsp;</a></span>~Importer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Assimp::Importer::~Importer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The object kept ownership of the imported data, which now will be destroyed along with the object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aba00e5dd1cb5ed67f709e994933efb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba00e5dd1cb5ed67f709e994933efb39">&#9670;&nbsp;</a></span>ApplyCustomizedPostProcessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_scene.html">aiScene</a>* Assimp::Importer::ApplyCustomizedPostProcessing </td>
          <td>(</td>
          <td class="paramtype">BaseProcess *&#160;</td>
          <td class="paramname"><em>rootProcess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requestValidation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5872e749c1451fee64183fc14f1fc81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5872e749c1451fee64183fc14f1fc81d">&#9670;&nbsp;</a></span>ApplyPostProcessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_scene.html">aiScene</a>* Assimp::Importer::ApplyPostProcessing </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply post-processing to an already-imported scene. </p>
<p>This is strictly equivalent to calling <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> with the same flags. However, you can use this separate function to inspect the imported scene first to fine-tune your post-processing setup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFlags</td><td>Provide a bitwise combination of the <a class="el" href="postprocess_8h.html#a64795260b95f5a4b3f3dc1be4f52e410" title="Defines the flags for all possible post processing steps.">aiPostProcessSteps</a> flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the post-processed data. This is still the same as the pointer returned by <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>. However, if post-processing fails, the scene could now be NULL. That's quite a rare case, post processing steps are not really designed to 'fail'. To be exact, the #aiProcess_ValidateDS flag is currently the only post processing step which can actually cause the scene to be reset to NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The method does nothing if no scene is currently bound to the <a class="el" href="class_assimp_1_1_importer.html#a2c207299ed05f1db1ad1e6dab005f719" title="Constructor.">Importer</a> instance. <br  />
 </dd></dl>

</div>
</div>
<a id="a53dafc3046abc33365a07c605716c5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dafc3046abc33365a07c605716c5d4">&#9670;&nbsp;</a></span>FreeScene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::Importer::FreeScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the current scene. </p>
<p>The function does nothing if no scene has previously been read via <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>. <a class="el" href="class_assimp_1_1_importer.html#a53dafc3046abc33365a07c605716c5d4" title="Frees the current scene.">FreeScene()</a> is called automatically by the destructor and <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> itself. <br  />
 </p>

</div>
</div>
<a id="a3ac36c9ab8668bd368de516c19bdcc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac36c9ab8668bd368de516c19bdcc11">&#9670;&nbsp;</a></span>GetErrorString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Assimp::Importer::GetErrorString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an error description of an error that occurred in <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>. </p>
<p>Returns an empty string if no error occurred. </p><dl class="section return"><dt>Returns</dt><dd>A description of the last error, an empty string if no error occurred. The string is never NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned function remains valid until one of the following methods is called: <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>, <a class="el" href="class_assimp_1_1_importer.html#a53dafc3046abc33365a07c605716c5d4" title="Frees the current scene.">FreeScene()</a>. </dd></dl>

</div>
</div>
<a id="ab06927d45d5adbf909040c8f5bac1e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06927d45d5adbf909040c8f5bac1e4d">&#9670;&nbsp;</a></span>GetExtensionList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::Importer::GetExtensionList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_string.html">aiString</a> &amp;&#160;</td>
          <td class="paramname"><em>szOut</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a full list of all file extensions supported by ASSIMP. </p>
<p>If a file extension is contained in the list this does of course not mean that ASSIMP is able to load all files with this extension &mdash; it simply means there is an importer loaded which claims to handle files with this file extension. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szOut</td><td>String to receive the extension list. Format of the list: "*.3ds;*.obj;*.dae". This is useful for use with the WinAPI call GetOpenFileName(Ex). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdc70c6efdf1b572094fe01089ceb158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc70c6efdf1b572094fe01089ceb158">&#9670;&nbsp;</a></span>GetExtensionList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a61d239a320b58eca56bacc46fc2c79b8">AI_FORCE_INLINE</a> void Assimp::Importer::GetExtensionList </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>szOut</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a full list of all file extensions supported by ASSIMP. </p>
<p>This function is provided for backward compatibility. See the <a class="el" href="structai_string.html" title="Represents an UTF-8 string, zero byte terminated.">aiString</a> version for detailed and up-to-date docs. </p><dl class="section see"><dt>See also</dt><dd>GetExtensionList(aiString&amp;) </dd></dl>

</div>
</div>
<a id="a35d624811e9ddfcd0a898797e6263c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d624811e9ddfcd0a898797e6263c22">&#9670;&nbsp;</a></span>GetImporter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseImporter* Assimp::Importer::GetImporter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szExtension</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the importer corresponding to a specific file extension. </p>
<p>This is quite similar to <a class="el" href="class_assimp_1_1_importer.html#a22bbe0ca29cc685b110b6853dd1e4157" title="Returns whether a given file extension is supported by ASSIMP.">IsExtensionSupported</a> except a BaseImporter instance is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szExtension</td><td>Extension to check for. The following formats are recognized (BAH being the file extension): "BAH" (comparison is case-insensitive), ".bah", "*.bah" (wild card and dot characters at the beginning of the extension are skipped). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if no importer is found </dd></dl>

</div>
</div>
<a id="a913543b8db0f09f286cc1b4f20bb3d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913543b8db0f09f286cc1b4f20bb3d35">&#9670;&nbsp;</a></span>GetImporter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseImporter* Assimp::Importer::GetImporter </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the importer corresponding to a specific index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to query, must be within [0,<a class="el" href="class_assimp_1_1_importer.html#a5397c7d93358b1a6983c74c5eb5c64a6" title="Get the number of importers currently registered with Assimp.">GetImporterCount()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance. NULL if the index does not exist. </dd></dl>

</div>
</div>
<a id="a5397c7d93358b1a6983c74c5eb5c64a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5397c7d93358b1a6983c74c5eb5c64a6">&#9670;&nbsp;</a></span>GetImporterCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Assimp::Importer::GetImporterCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of importers currently registered with <a class="el" href="namespace_assimp.html">Assimp</a>. </p>

</div>
</div>
<a id="aa9158a5ec0caba90cb1a3183c065634f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9158a5ec0caba90cb1a3183c065634f">&#9670;&nbsp;</a></span>GetImporterIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Assimp::Importer::GetImporterIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szExtension</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the importer index corresponding to a specific file extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szExtension</td><td>Extension to check for. The following formats are recognized (BAH being the file extension): "BAH" (comparison is case-insensitive), ".bah", "*.bah" (wild card and dot characters at the beginning of the extension are skipped). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(size_t)-1 if no importer is found </dd></dl>

</div>
</div>
<a id="a2f9db052a2507d3a77aec782dc8149cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9db052a2507d3a77aec782dc8149cf">&#9670;&nbsp;</a></span>GetImporterInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_importer_desc.html">aiImporterDesc</a>* Assimp::Importer::GetImporterInfo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get meta data for the importer corresponding to a specific index. </p>
<p>For the declaration of <a class="el" href="structai_importer_desc.html" title="Meta information about a particular importer.">aiImporterDesc</a>, include &lt;<a class="el" href="importerdesc_8h.html" title="aiImporterFlags, aiImporterDesc implementation.">assimp/importerdesc.h</a>&gt;. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to query, must be within [0,<a class="el" href="class_assimp_1_1_importer.html#a5397c7d93358b1a6983c74c5eb5c64a6" title="Get the number of importers currently registered with Assimp.">GetImporterCount()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> meta data structure, NULL if the index does not exist or if the importer doesn't offer meta information ( importers may do this at the cost of being hated by their peers). </dd></dl>

</div>
</div>
<a id="a72f4d2821d38b97f630981f9236901e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f4d2821d38b97f630981f9236901e8">&#9670;&nbsp;</a></span>GetIOHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a>* Assimp::Importer::GetIOHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the IO handler that is currently set. </p>
<p>You can use <a class="el" href="class_assimp_1_1_importer.html#ad2c940def9c4d01709e44a4e781e757d" title="Checks whether a default IO handler is active A default handler is active as long the application doe...">IsDefaultIOHandler()</a> to check whether the returned interface is the default IO handler provided by ASSIMP. The default handler is active as long the application doesn't supply its own custom IO handler via <a class="el" href="class_assimp_1_1_importer.html#a1161f46318af18bb86dfe0fc3edea4df" title="Supplies a custom IO handler to the importer to use to open and access files.">SetIOHandler()</a>. </p><dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="class_assimp_1_1_i_o_system.html" title="CPP-API: Interface to the file system.">IOSystem</a> interface, never NULL. </dd></dl>

</div>
</div>
<a id="a6d6cd3b06de9438744a17f61395a0bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6cd3b06de9438744a17f61395a0bf0">&#9670;&nbsp;</a></span>GetMemoryRequirements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::Importer::GetMemoryRequirements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_memory_info.html">aiMemoryInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the storage allocated by ASSIMP to hold the scene data in memory. </p>
<p>This refers to the currently loaded file, see <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Data structure to be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The returned memory statistics refer to the actual size of the use data of the <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a>. Heap-related overhead is (naturally) not included. </dd></dl>

</div>
</div>
<a id="a60eb9042fb85bfbd61a863e131a56ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60eb9042fb85bfbd61a863e131a56ecd">&#9670;&nbsp;</a></span>GetOrphanedScene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structai_scene.html">aiScene</a>* Assimp::Importer::GetOrphanedScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the scene loaded by the last successful call to <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> and releases the scene from the ownership of the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance. </p>
<p>The application is now responsible for deleting the scene. Any further calls to <a class="el" href="class_assimp_1_1_importer.html#ae5f94a29007ed7c873be138ecdb4b056" title="Returns the scene loaded by the last successful call to ReadFile()">GetScene()</a> or <a class="el" href="class_assimp_1_1_importer.html#a60eb9042fb85bfbd61a863e131a56ecd" title="Returns the scene loaded by the last successful call to ReadFile() and releases the scene from the ow...">GetOrphanedScene()</a> will return NULL - until a new scene has been loaded via <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Current scene or NULL if there is currently no scene loaded </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this method with maximal caution, and only if you have to. By design, <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a>'s are exclusively maintained, allocated and deallocated by <a class="el" href="namespace_assimp.html">Assimp</a> and no one else. The reasoning behind this is the golden rule that deallocations should always be done by the module that did the original allocation because heaps are not necessarily shared. <a class="el" href="class_assimp_1_1_importer.html#a60eb9042fb85bfbd61a863e131a56ecd" title="Returns the scene loaded by the last successful call to ReadFile() and releases the scene from the ow...">GetOrphanedScene()</a> enforces you to delete the returned scene by yourself, but this will only be fine if and only if you're using the same heap as assimp. On Windows, it's typically fine provided everything is linked against the multithreaded-dll version of the runtime library. It will work as well for static linkage with <a class="el" href="namespace_assimp.html">Assimp</a>. </dd></dl>

</div>
</div>
<a id="a14201de344db7c66fa514f7f092ae10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14201de344db7c66fa514f7f092ae10b">&#9670;&nbsp;</a></span>GetProgressHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assimp_1_1_progress_handler.html">ProgressHandler</a>* Assimp::Importer::GetProgressHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the progress handler that is currently set. </p>
<p>You can use <a class="el" href="class_assimp_1_1_importer.html#a34062906cb6b9af8abaeda36737d14ae" title="Checks whether a default progress handler is active A default handler is active as long the applicati...">IsDefaultProgressHandler()</a> to check whether the returned interface is the default handler provided by ASSIMP. The default handler is active as long the application doesn't supply its own custom handler via <a class="el" href="class_assimp_1_1_importer.html#a6a4d830ffb3f77a3c7c919e0af006920" title="Supplies a custom progress handler to the importer.">SetProgressHandler()</a>. </p><dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="class_assimp_1_1_progress_handler.html" title="CPP-API: Abstract interface for custom progress report receivers.">ProgressHandler</a> interface, never NULL. </dd></dl>

</div>
</div>
<a id="a39e654c887f684cc12f792ca1daebfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e654c887f684cc12f792ca1daebfee">&#9670;&nbsp;</a></span>GetPropertyBool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::GetPropertyBool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bErrorReturn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a boolean configuration property. </p>
<p>Boolean properties are stored on the integer stack internally so it's possible to set them via <a class="el" href="class_assimp_1_1_importer.html#a4af22a88eddf464d949a761149c72825" title="Set a boolean configuration property.">SetPropertyBool</a> and query them with <a class="el" href="class_assimp_1_1_importer.html#a39e654c887f684cc12f792ca1daebfee" title="Get a boolean configuration property.">GetPropertyBool</a> and vice versa. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_assimp_1_1_importer.html#ac6f348464e03176bc6dd790226122b36" title="Get a configuration property.">GetPropertyInteger()</a> </dd></dl>

</div>
</div>
<a id="a3a5f327bc30dfe95db6d8ff9297d4aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5f327bc30dfe95db6d8ff9297d4aab">&#9670;&nbsp;</a></span>GetPropertyFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#af221f9bbc3e0dc43a46efaaac6dab067">ai_real</a> Assimp::Importer::GetPropertyFloat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#af221f9bbc3e0dc43a46efaaac6dab067">ai_real</a>&#160;</td>
          <td class="paramname"><em>fErrorReturn</em> = <code>10e10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a floating-point configuration property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_assimp_1_1_importer.html#ac6f348464e03176bc6dd790226122b36" title="Get a configuration property.">GetPropertyInteger()</a> </dd></dl>

</div>
</div>
<a id="ac6f348464e03176bc6dd790226122b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f348464e03176bc6dd790226122b36">&#9670;&nbsp;</a></span>GetPropertyInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Assimp::Importer::GetPropertyInteger </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iErrorReturn</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a configuration property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szName</td><td>Name of the property. All supported properties are defined in the aiConfig.g header (all constants share the prefix AI_CONFIG_XXX). </td></tr>
    <tr><td class="paramname">iErrorReturn</td><td>Value that is returned if the property is not found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current value of the property </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Property of different types (float, int, string ..) are kept on different lists, so calling <a class="el" href="class_assimp_1_1_importer.html#a2542eed3d5f491025c4095b4e55fa068" title="Set an integer configuration property.">SetPropertyInteger()</a> for a floating-point property has no effect - the loader will call <a class="el" href="class_assimp_1_1_importer.html#a3a5f327bc30dfe95db6d8ff9297d4aab" title="Get a floating-point configuration property.">GetPropertyFloat()</a> to read the property, but it won't be there. </dd></dl>

</div>
</div>
<a id="a53665d41547cc298c53b5341c99ee60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53665d41547cc298c53b5341c99ee60e">&#9670;&nbsp;</a></span>GetPropertyMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_matrix4x4.html">aiMatrix4x4</a> Assimp::Importer::GetPropertyMatrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structai_matrix4x4.html">aiMatrix4x4</a> &amp;&#160;</td>
          <td class="paramname"><em>sErrorReturn</em> = <code><a class="el" href="structai_matrix4x4.html">aiMatrix4x4</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a matrix configuration property. </p>
<p>The return value remains valid until the property is modified. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_assimp_1_1_importer.html#ac6f348464e03176bc6dd790226122b36" title="Get a configuration property.">GetPropertyInteger()</a> </dd></dl>

</div>
</div>
<a id="afc97e5eeaa39c9d7b6fb60703b78cdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc97e5eeaa39c9d7b6fb60703b78cdf0">&#9670;&nbsp;</a></span>GetPropertyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string Assimp::Importer::GetPropertyString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sErrorReturn</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string configuration property. </p>
<p>The return value remains valid until the property is modified. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_assimp_1_1_importer.html#ac6f348464e03176bc6dd790226122b36" title="Get a configuration property.">GetPropertyInteger()</a> </dd></dl>

</div>
</div>
<a id="ae5f94a29007ed7c873be138ecdb4b056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f94a29007ed7c873be138ecdb4b056">&#9670;&nbsp;</a></span>GetScene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_scene.html">aiScene</a>* Assimp::Importer::GetScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the scene loaded by the last successful call to <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>Current scene or NULL if there is currently no scene loaded </dd></dl>

</div>
</div>
<a id="ad2c940def9c4d01709e44a4e781e757d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c940def9c4d01709e44a4e781e757d">&#9670;&nbsp;</a></span>IsDefaultIOHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::IsDefaultIOHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a default IO handler is active A default handler is active as long the application doesn't supply its own custom IO handler via <a class="el" href="class_assimp_1_1_importer.html#a1161f46318af18bb86dfe0fc3edea4df" title="Supplies a custom IO handler to the importer to use to open and access files.">SetIOHandler()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true by default </dd></dl>

</div>
</div>
<a id="a34062906cb6b9af8abaeda36737d14ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34062906cb6b9af8abaeda36737d14ae">&#9670;&nbsp;</a></span>IsDefaultProgressHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::IsDefaultProgressHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a default progress handler is active A default handler is active as long the application doesn't supply its own custom progress handler via <a class="el" href="class_assimp_1_1_importer.html#a6a4d830ffb3f77a3c7c919e0af006920" title="Supplies a custom progress handler to the importer.">SetProgressHandler()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>true by default </dd></dl>

</div>
</div>
<a id="a22bbe0ca29cc685b110b6853dd1e4157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bbe0ca29cc685b110b6853dd1e4157">&#9670;&nbsp;</a></span>IsExtensionSupported() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::IsExtensionSupported </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szExtension</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a given file extension is supported by ASSIMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szExtension</td><td>Extension to be checked. Must include a trailing dot '.'. Example: ".3ds", ".md3". Cases-insensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the extension is supported, false otherwise </dd></dl>

</div>
</div>
<a id="a4d49e3c8ecf28336d78f9f5e502990ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d49e3c8ecf28336d78f9f5e502990ce">&#9670;&nbsp;</a></span>IsExtensionSupported() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="defs_8h.html#a61d239a320b58eca56bacc46fc2c79b8">AI_FORCE_INLINE</a> bool Assimp::Importer::IsExtensionSupported </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>szExtension</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a given file extension is supported by ASSIMP. </p>
<p>This function is provided for backward compatibility. See the const char* version for detailed and up-to-date docs. </p><dl class="section see"><dt>See also</dt><dd>IsExtensionSupported(const char*) </dd></dl>

</div>
</div>
<a id="ac112839f323a630f83395acb74746827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac112839f323a630f83395acb74746827">&#9670;&nbsp;</a></span>Pimpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ImporterPimpl* Assimp::Importer::Pimpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private, do not use. </p>

</div>
</div>
<a id="a5a85077725374402b4d6e107b03ce845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a85077725374402b4d6e107b03ce845">&#9670;&nbsp;</a></span>Pimpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ImporterPimpl* Assimp::Importer::Pimpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a174418ab41d5b8bc51a044895cb991e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174418ab41d5b8bc51a044895cb991e5">&#9670;&nbsp;</a></span>ReadFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_scene.html">aiScene</a>* Assimp::Importer::ReadFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the given file and returns its contents if successful. </p>
<p>If the call succeeds, the contents of the file are returned as a pointer to an <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> object. The returned data is intended to be read-only, the importer object keeps ownership of the data and will destroy it upon destruction. If the import fails, NULL is returned. A human-readable error description can be retrieved by calling <a class="el" href="class_assimp_1_1_importer.html#a3ac36c9ab8668bd368de516c19bdcc11" title="Returns an error description of an error that occurred in ReadFile().">GetErrorString()</a>. The previous scene will be deleted during this call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFile</td><td>Path and filename to the file to be imported. </td></tr>
    <tr><td class="paramname">pFlags</td><td>Optional post processing steps to be executed after a successful import. Provide a bitwise combination of the <a class="el" href="postprocess_8h.html#a64795260b95f5a4b3f3dc1be4f52e410" title="Defines the flags for all possible post processing steps.">aiPostProcessSteps</a> flags. If you wish to inspect the imported scene first in order to fine-tune your post-processing setup, consider to use <a class="el" href="class_assimp_1_1_importer.html#a5872e749c1451fee64183fc14f1fc81d" title="Apply post-processing to an already-imported scene.">ApplyPostProcessing()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the imported data, NULL if the import failed. The pointer to the scene remains in possession of the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance. Use <a class="el" href="class_assimp_1_1_importer.html#a60eb9042fb85bfbd61a863e131a56ecd" title="Returns the scene loaded by the last successful call to ReadFile() and releases the scene from the ow...">GetOrphanedScene()</a> to take ownership of it.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespace_assimp.html">Assimp</a> is able to determine the file format of a file automatically. </dd></dl>

</div>
</div>
<a id="ad9a9f3905924744b2cdce0f3fc131a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a9f3905924744b2cdce0f3fc131a87">&#9670;&nbsp;</a></span>ReadFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="defs_8h.html#a61d239a320b58eca56bacc46fc2c79b8">AI_FORCE_INLINE</a> <a class="el" href="structai_scene.html">aiScene</a> * Assimp::Importer::ReadFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the given file and returns its contents if successful. </p>
<p>class <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a></p>
<p>This function is provided for backward compatibility. See the const char* version for detailed docs. </p><dl class="section see"><dt>See also</dt><dd>ReadFile(const char*, pFlags) <br  />
 </dd></dl>

</div>
</div>
<a id="a9b3c5e8b1042702f449e84a95b3324f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3c5e8b1042702f449e84a95b3324f6">&#9670;&nbsp;</a></span>ReadFileFromMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structai_scene.html">aiScene</a>* Assimp::Importer::ReadFileFromMemory </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pHint</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the given file from a memory buffer and returns its contents if successful. </p>
<p>If the call succeeds, the contents of the file are returned as a pointer to an <a class="el" href="structai_scene.html" title="The root structure of the imported data.">aiScene</a> object. The returned data is intended to be read-only, the importer object keeps ownership of the data and will destroy it upon destruction. If the import fails, NULL is returned. A human-readable error description can be retrieved by calling <a class="el" href="class_assimp_1_1_importer.html#a3ac36c9ab8668bd368de516c19bdcc11" title="Returns an error description of an error that occurred in ReadFile().">GetErrorString()</a>. The previous scene will be deleted during this call. Calling this method doesn't affect the active <a class="el" href="class_assimp_1_1_i_o_system.html" title="CPP-API: Interface to the file system.">IOSystem</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>Pointer to the file data </td></tr>
    <tr><td class="paramname">pLength</td><td>Length of pBuffer, in bytes </td></tr>
    <tr><td class="paramname">pFlags</td><td>Optional post processing steps to be executed after a successful import. Provide a bitwise combination of the <a class="el" href="postprocess_8h.html#a64795260b95f5a4b3f3dc1be4f52e410" title="Defines the flags for all possible post processing steps.">aiPostProcessSteps</a> flags. If you wish to inspect the imported scene first in order to fine-tune your post-processing setup, consider to use <a class="el" href="class_assimp_1_1_importer.html#a5872e749c1451fee64183fc14f1fc81d" title="Apply post-processing to an already-imported scene.">ApplyPostProcessing()</a>. </td></tr>
    <tr><td class="paramname">pHint</td><td>An additional hint to the library. If this is a non empty string, the library looks for a loader to support the file extension specified by pHint and passes the file to the first matching loader. If this loader is unable to completely the request, the library continues and tries to determine the file format on its own, a task that may or may not be successful. Check the return value, and you'll know ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the imported data, NULL if the import failed. The pointer to the scene remains in possession of the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance. Use <a class="el" href="class_assimp_1_1_importer.html#a60eb9042fb85bfbd61a863e131a56ecd" title="Returns the scene loaded by the last successful call to ReadFile() and releases the scene from the ow...">GetOrphanedScene()</a> to take ownership of it.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a straightforward way to decode models from memory buffers, but it doesn't handle model formats that spread their data across multiple files or even directories. Examples include OBJ or MD3, which outsource parts of their material info into external scripts. If you need full functionality, provide a custom <a class="el" href="class_assimp_1_1_i_o_system.html" title="CPP-API: Interface to the file system.">IOSystem</a> to make <a class="el" href="namespace_assimp.html">Assimp</a> find these files and use the regular <a class="el" href="class_assimp_1_1_importer.html#a174418ab41d5b8bc51a044895cb991e5" title="Reads the given file and returns its contents if successful.">ReadFile()</a> API. </dd></dl>

</div>
</div>
<a id="a3846294ffe76d91a1d3096d22d7c6b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3846294ffe76d91a1d3096d22d7c6b7d">&#9670;&nbsp;</a></span>RegisterLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1f78dfb65090aa930cabb984c8abe711">aiReturn</a> Assimp::Importer::RegisterLoader </td>
          <td>(</td>
          <td class="paramtype">BaseImporter *&#160;</td>
          <td class="paramname"><em>pImp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a new loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImp</td><td><a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> to be added. The <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance takes ownership of the pointer, so it will be automatically deleted with the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AI_SUCCESS if the loader has been added. The registration fails if there is already a loader for a specific file extension. </dd></dl>

</div>
</div>
<a id="a102650d3648c0e414a1e73bdad9bed35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102650d3648c0e414a1e73bdad9bed35">&#9670;&nbsp;</a></span>RegisterPPStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1f78dfb65090aa930cabb984c8abe711">aiReturn</a> Assimp::Importer::RegisterPPStep </td>
          <td>(</td>
          <td class="paramtype">BaseProcess *&#160;</td>
          <td class="paramname"><em>pImp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a new post-process step. </p>
<p>At the moment, there's a small limitation: new post processing steps are added to end of the list, or in other words, executed last, after all built-in steps. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImp</td><td>Post-process step to be added. The <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance takes ownership of the pointer, so it will be automatically deleted with the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AI_SUCCESS if the step has been added correctly. </dd></dl>

</div>
</div>
<a id="a9bb793072c84c784279d0f6e870bb42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb793072c84c784279d0f6e870bb42d">&#9670;&nbsp;</a></span>SetExtraVerbose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::Importer::SetExtraVerbose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables "extra verbose" mode. </p>
<p>'Extra verbose' means the data structure is validated after <em>every</em> single post processing step to make sure everyone modifies the data structure in a well-defined manner. This is a debug feature and not intended for use in production environments. </p>

</div>
</div>
<a id="a1161f46318af18bb86dfe0fc3edea4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1161f46318af18bb86dfe0fc3edea4df">&#9670;&nbsp;</a></span>SetIOHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::Importer::SetIOHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_i_o_system.html">IOSystem</a> *&#160;</td>
          <td class="paramname"><em>pIOHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies a custom IO handler to the importer to use to open and access files. </p>
<p>If you need the importer to use custom IO logic to access the files, you need to provide a custom implementation of <a class="el" href="class_assimp_1_1_i_o_system.html" title="CPP-API: Interface to the file system.">IOSystem</a> and IOFile to the importer. Then create an instance of your custom <a class="el" href="class_assimp_1_1_i_o_system.html" title="CPP-API: Interface to the file system.">IOSystem</a> implementation and supply it by this function.</p>
<p>The <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> takes ownership of the object and will destroy it afterwards. The previously assigned handler will be deleted. Pass NULL to take again ownership of your <a class="el" href="class_assimp_1_1_i_o_system.html" title="CPP-API: Interface to the file system.">IOSystem</a> and reset <a class="el" href="namespace_assimp.html">Assimp</a> to use its default implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIOHandler</td><td>The IO handler to be used in all file accesses of the <a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a4d830ffb3f77a3c7c919e0af006920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4d830ffb3f77a3c7c919e0af006920">&#9670;&nbsp;</a></span>SetProgressHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assimp::Importer::SetProgressHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_assimp_1_1_progress_handler.html">ProgressHandler</a> *&#160;</td>
          <td class="paramname"><em>pHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supplies a custom progress handler to the importer. </p>
<p>This interface exposes a #Update() callback, which is called more or less periodically (please don't sue us if it isn't as periodically as you'd like it to have ...). This can be used to implement progress bars and loading timeouts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandler</td><td>Progress callback interface. Pass NULL to disable progress reporting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Progress handlers can be used to abort the loading at almost any time. </dd></dl>

</div>
</div>
<a id="a4af22a88eddf464d949a761149c72825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af22a88eddf464d949a761149c72825">&#9670;&nbsp;</a></span>SetPropertyBool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::SetPropertyBool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a boolean configuration property. </p>
<p>Boolean properties are stored on the integer stack internally so it's possible to set them via <a class="el" href="class_assimp_1_1_importer.html#a4af22a88eddf464d949a761149c72825" title="Set a boolean configuration property.">SetPropertyBool</a> and query them with <a class="el" href="class_assimp_1_1_importer.html#a39e654c887f684cc12f792ca1daebfee" title="Get a boolean configuration property.">GetPropertyBool</a> and vice versa. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_assimp_1_1_importer.html#a2542eed3d5f491025c4095b4e55fa068" title="Set an integer configuration property.">SetPropertyInteger()</a> </dd></dl>

</div>
</div>
<a id="ad38af78d6fe4b1f132d2534d8a84deea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38af78d6fe4b1f132d2534d8a84deea">&#9670;&nbsp;</a></span>SetPropertyFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::SetPropertyFloat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="defs_8h.html#af221f9bbc3e0dc43a46efaaac6dab067">ai_real</a>&#160;</td>
          <td class="paramname"><em>fValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a floating-point configuration property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_assimp_1_1_importer.html#a2542eed3d5f491025c4095b4e55fa068" title="Set an integer configuration property.">SetPropertyInteger()</a> </dd></dl>

</div>
</div>
<a id="a2542eed3d5f491025c4095b4e55fa068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2542eed3d5f491025c4095b4e55fa068">&#9670;&nbsp;</a></span>SetPropertyInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::SetPropertyInteger </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an integer configuration property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szName</td><td>Name of the property. All supported properties are defined in the aiConfig.g header (all constants share the prefix AI_CONFIG_XXX and are simple strings). </td></tr>
    <tr><td class="paramname">iValue</td><td>New value of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the property was set before. The new value replaces the previous value in this case. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Property of different types (float, int, string ..) are kept on different stacks, so calling <a class="el" href="class_assimp_1_1_importer.html#a2542eed3d5f491025c4095b4e55fa068" title="Set an integer configuration property.">SetPropertyInteger()</a> for a floating-point property has no effect - the loader will call <a class="el" href="class_assimp_1_1_importer.html#a3a5f327bc30dfe95db6d8ff9297d4aab" title="Get a floating-point configuration property.">GetPropertyFloat()</a> to read the property, but it won't be there. </dd></dl>

</div>
</div>
<a id="acd128e5fb5777ef238b8bd1454a9c3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd128e5fb5777ef238b8bd1454a9c3ad">&#9670;&nbsp;</a></span>SetPropertyMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::SetPropertyMatrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structai_matrix4x4.html">aiMatrix4x4</a> &amp;&#160;</td>
          <td class="paramname"><em>sValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a matrix configuration property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_assimp_1_1_importer.html#a2542eed3d5f491025c4095b4e55fa068" title="Set an integer configuration property.">SetPropertyInteger()</a> </dd></dl>

</div>
</div>
<a id="a854087b213981108e3e464cf4d293fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854087b213981108e3e464cf4d293fed">&#9670;&nbsp;</a></span>SetPropertyString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::SetPropertyString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a string configuration property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_assimp_1_1_importer.html#a2542eed3d5f491025c4095b4e55fa068" title="Set an integer configuration property.">SetPropertyInteger()</a> </dd></dl>

</div>
</div>
<a id="a3b1f5af2c763b13aca0f324b19001722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1f5af2c763b13aca0f324b19001722">&#9670;&nbsp;</a></span>UnregisterLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1f78dfb65090aa930cabb984c8abe711">aiReturn</a> Assimp::Importer::UnregisterLoader </td>
          <td>(</td>
          <td class="paramtype">BaseImporter *&#160;</td>
          <td class="paramname"><em>pImp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImp</td><td><a class="el" href="class_assimp_1_1_importer.html" title="CPP-API: The Importer class forms an C++ interface to the functionality of the Open Asset Import Libr...">Importer</a> to be unregistered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AI_SUCCESS if the loader has been removed. The function fails if the loader is currently in use (this could happen if the <a class="el" href="class_assimp_1_1_importer.html#a2c207299ed05f1db1ad1e6dab005f719" title="Constructor.">Importer</a> instance is used by more than one thread) or if it has not yet been registered. </dd></dl>

</div>
</div>
<a id="a3a683671c7c40638b1103c5d3648d86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a683671c7c40638b1103c5d3648d86c">&#9670;&nbsp;</a></span>UnregisterPPStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a1f78dfb65090aa930cabb984c8abe711">aiReturn</a> Assimp::Importer::UnregisterPPStep </td>
          <td>(</td>
          <td class="paramtype">BaseProcess *&#160;</td>
          <td class="paramname"><em>pImp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a post-process step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImp</td><td>Step to be unregistered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AI_SUCCESS if the step has been removed. The function fails if the step is currently in use (this could happen if the <a class="el" href="class_assimp_1_1_importer.html#a2c207299ed05f1db1ad1e6dab005f719" title="Constructor.">Importer</a> instance is used by more than one thread) or if it has not yet been registered. </dd></dl>

</div>
</div>
<a id="af0292c1603ff9b483a5deba4d183eba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0292c1603ff9b483a5deba4d183eba5">&#9670;&nbsp;</a></span>ValidateFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Assimp::Importer::ValidateFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pFlags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a given set of post-processing flags is supported. </p>
<p>Some flags are mutually exclusive, others are probably not available because your excluded them from your <a class="el" href="namespace_assimp.html">Assimp</a> builds. Calling this function is recommended if you're unsure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFlags</td><td>Bitwise combination of the aiPostProcess flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this flag combination is fine. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3affe8f98fc9a3b75fc3cb4c4415b37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3affe8f98fc9a3b75fc3cb4c4415b37c">&#9670;&nbsp;</a></span>MaxLenHint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Assimp::Importer::MaxLenHint = 200</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The upper limit for hints. </p>

</div>
</div>
<a id="a3928bb8d375fd676dd5dbe33382e46ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3928bb8d375fd676dd5dbe33382e46ce">&#9670;&nbsp;</a></span>pimpl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ImporterPimpl* Assimp::Importer::pimpl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/assimp/<a class="el" href="_importer_8hpp_source.html">Importer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_assimp.html">Assimp</a></li><li class="navelem"><a class="el" href="class_assimp_1_1_importer.html">Importer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
